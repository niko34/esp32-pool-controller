#include "pump_controller.h"
#include "config.h"
#include "logger.h"
#include "sensors.h"
#include <esp_task_wdt.h>

PumpControllerClass PumpController;

PumpControllerClass::PumpControllerClass() {
  pumps[0] = {PUMP1_PWM_PIN, PUMP1_IN1_PIN, PUMP1_IN2_PIN, PUMP1_CHANNEL};
  pumps[1] = {PUMP2_PWM_PIN, PUMP2_IN1_PIN, PUMP2_IN2_PIN, PUMP2_CHANNEL};
}

void PumpControllerClass::begin() {
  for (int i = 0; i < 2; ++i) {
    pinMode(pumps[i].in1Pin, OUTPUT);
    pinMode(pumps[i].in2Pin, OUTPUT);
    digitalWrite(pumps[i].in1Pin, LOW);
    digitalWrite(pumps[i].in2Pin, LOW);
    ledcSetup(pumps[i].channel, PUMP_PWM_FREQ, PUMP_PWM_RES_BITS);
    ledcAttachPin(pumps[i].pwmPin, pumps[i].channel);
    ledcWrite(pumps[i].channel, 0);
  }
  systemLogger.info("Contrôleur de pompes initialisé");
}

void PumpControllerClass::applyPumpDuty(int index, uint8_t duty) {
  duty = duty > MAX_PWM_DUTY ? MAX_PWM_DUTY : duty;
  if (pumpDuty[index] == duty) return;

  pumpDuty[index] = duty;
  if (duty == 0) {
    ledcWrite(pumps[index].channel, 0);
    digitalWrite(pumps[index].in1Pin, LOW);
    digitalWrite(pumps[index].in2Pin, LOW);
  } else {
    digitalWrite(pumps[index].in1Pin, HIGH);
    digitalWrite(pumps[index].in2Pin, LOW);
    ledcWrite(pumps[index].channel, duty);
  }
}

void PumpControllerClass::refreshDosingState(DosingState& state, unsigned long now) {
  if (state.windowStart == 0) {
    state.windowStart = now;
    state.lastTimestamp = now;
  }

  // Réinitialiser la fenêtre toutes les heures
  if (now - state.windowStart >= 3600000UL) {
    state.windowStart = now;
    state.usedMs = 0;
  }

  // Accumuler le temps d'injection
  if (state.active) {
    unsigned long delta = now - state.lastTimestamp;
    state.usedMs += delta;
    if (state.usedMs > 3600000UL) state.usedMs = 3600000UL;
  }

  state.lastTimestamp = now;
}

float PumpControllerClass::computePID(PIDController& pid, float error, unsigned long now) {
  if (pid.lastTime == 0) {
    pid.lastTime = now;
    pid.lastError = error;
    return 0.0f;
  }

  float dt = (now - pid.lastTime) / 1000.0f; // en secondes
  if (dt <= 0.0f || dt > 10.0f) { // Éviter les divisions par zéro et les deltas aberrants
    pid.lastTime = now;
    return 0.0f;
  }

  // Calcul PID
  float proportional = pid.kp * error;

  pid.integral += error * dt;
  // Anti-windup
  if (pid.integral > pid.integralMax) pid.integral = pid.integralMax;
  if (pid.integral < -pid.integralMax) pid.integral = -pid.integralMax;
  float integralTerm = pid.ki * pid.integral;

  float derivative = pid.kd * (error - pid.lastError) / dt;

  float output = proportional + integralTerm + derivative;

  pid.lastError = error;
  pid.lastTime = now;

  return output > 0.0f ? output : 0.0f;
}

float PumpControllerClass::computeFlowFromError(float error, float deadband, const PumpControlParams& params) {
  float delta = error - deadband;
  if (delta <= 0.0f) return 0.0f;

  float normalized = delta / params.maxError;
  if (normalized < 0.0f) normalized = 0.0f;
  if (normalized > 1.0f) normalized = 1.0f;

  return params.minFlowMlPerMin + normalized * (params.maxFlowMlPerMin - params.minFlowMlPerMin);
}

uint8_t PumpControllerClass::flowToDuty(const PumpControlParams& params, float flowMlPerMin) {
  if (flowMlPerMin <= 0.0f) return 0;
  if (flowMlPerMin < params.minFlowMlPerMin) flowMlPerMin = params.minFlowMlPerMin;
  if (flowMlPerMin > params.maxFlowMlPerMin) flowMlPerMin = params.maxFlowMlPerMin;

  float normalized = (flowMlPerMin - params.minFlowMlPerMin) / (params.maxFlowMlPerMin - params.minFlowMlPerMin);
  if (normalized < 0.0f) normalized = 0.0f;
  if (normalized > 1.0f) normalized = 1.0f;

  uint8_t duty = MIN_ACTIVE_DUTY + static_cast<uint8_t>(roundf(normalized * (MAX_PWM_DUTY - MIN_ACTIVE_DUTY)));
  if (duty > MAX_PWM_DUTY) duty = MAX_PWM_DUTY;

  return duty;
}

bool PumpControllerClass::checkSafetyLimits(bool isPhPump) {
  unsigned long now = millis();

  // Vérifier si on change de jour (toutes les 24h)
  if (safetyLimits.dayStartTimestamp == 0) {
    safetyLimits.dayStartTimestamp = now;
  }

  if (now - safetyLimits.dayStartTimestamp >= 86400000UL) { // 24h en ms
    // Nouveau jour, réinitialiser les compteurs
    safetyLimits.dailyPhInjectedMl = 0;
    safetyLimits.dailyOrpInjectedMl = 0;
    safetyLimits.phLimitReached = false;
    safetyLimits.orpLimitReached = false;
    safetyLimits.dayStartTimestamp = now;
    systemLogger.info("Réinitialisation compteurs journaliers de sécurité");
  }

  if (isPhPump) {
    if (safetyLimits.dailyPhInjectedMl >= safetyLimits.maxPhMinusMlPerDay) {
      if (!safetyLimits.phLimitReached) {
        systemLogger.critical("LIMITE JOURNALIÈRE pH- ATTEINTE: " + String(safetyLimits.dailyPhInjectedMl) + " ml");
        safetyLimits.phLimitReached = true;
      }
      return false;
    }
  } else {
    if (safetyLimits.dailyOrpInjectedMl >= safetyLimits.maxChlorineMlPerDay) {
      if (!safetyLimits.orpLimitReached) {
        systemLogger.critical("LIMITE JOURNALIÈRE CHLORE ATTEINTE: " + String(safetyLimits.dailyOrpInjectedMl) + " ml");
        safetyLimits.orpLimitReached = true;
      }
      return false;
    }
  }

  return true;
}

void PumpControllerClass::updateSafetyTracking(bool isPhPump, float flowMlPerMin, unsigned long deltaMs) {
  if (deltaMs == 0 || flowMlPerMin <= 0.0f) return;

  float injectedMl = (flowMlPerMin / 60000.0f) * deltaMs;

  if (isPhPump) {
    safetyLimits.dailyPhInjectedMl += static_cast<unsigned long>(injectedMl);
  } else {
    safetyLimits.dailyOrpInjectedMl += static_cast<unsigned long>(injectedMl);
  }
}

void PumpControllerClass::update() {
  unsigned long now = millis();
  refreshDosingState(phDosingState, now);
  refreshDosingState(orpDosingState, now);

  if (!sensors.isInitialized()) {
    phDosingState.active = false;
    orpDosingState.active = false;
    applyPumpDuty(0, 0);
    applyPumpDuty(1, 0);
    return;
  }

  uint8_t desiredDuty[2] = {0, 0};
  bool phActive = false;
  bool orpActive = false;
  float phFlow = 0.0f;
  float orpFlow = 0.0f;

  // Calcul des limites d'injection avec accélération simulation
  int phLimitSec = mqttCfg.phInjectionLimitSeconds;
  if (phLimitSec < 0) phLimitSec = 0;
  unsigned long phLimitMs = static_cast<unsigned long>(phLimitSec) * 1000UL;

  if (simulationCfg.enabled && phLimitMs > 0) {
    float accel = simulationCfg.timeAcceleration;
    if (accel < 1.0f) accel = 1.0f;
    double scaled = static_cast<double>(phLimitMs) * accel;
    phLimitMs = (scaled > UINT32_MAX) ? UINT32_MAX : static_cast<unsigned long>(scaled);
  }

  int orpLimitSec = mqttCfg.orpInjectionLimitSeconds;
  if (orpLimitSec < 0) orpLimitSec = 0;
  unsigned long orpLimitMs = static_cast<unsigned long>(orpLimitSec) * 1000UL;

  if (simulationCfg.enabled && orpLimitMs > 0) {
    float accel = simulationCfg.timeAcceleration;
    if (accel < 1.0f) accel = 1.0f;
    double scaled = static_cast<double>(orpLimitMs) * accel;
    orpLimitMs = (scaled > UINT32_MAX) ? UINT32_MAX : static_cast<unsigned long>(scaled);
  }

  bool phLimitOk = (phLimitMs == 0) || (phDosingState.usedMs < phLimitMs);
  bool orpLimitOk = (orpLimitMs == 0) || (orpDosingState.usedMs < orpLimitMs);

  // Vérifier les limites de sécurité journalières
  bool phSafetyOk = checkSafetyLimits(true);
  bool orpSafetyOk = checkSafetyLimits(false);

  // Contrôle pH
  if (mqttCfg.phEnabled && phLimitOk && phSafetyOk) {
    float phValue = sensors.getPh();
    float diff = phValue - mqttCfg.phTarget;
    float flow = computeFlowFromError(diff, PH_DEADBAND, phPumpControl);

    if (flow > 0.0f) {
      int index = pumpIndexFromNumber(mqttCfg.phPump);
      uint8_t duty = flowToDuty(phPumpControl, flow);
      if (duty > desiredDuty[index]) desiredDuty[index] = duty;
      if (duty > 0) {
        phActive = true;
        phFlow = flow;
      }
    }
  }

  // Contrôle ORP
  if (mqttCfg.orpEnabled && orpLimitOk && orpSafetyOk) {
    float orpValue = sensors.getOrp();
    float diff = orpValue - mqttCfg.orpTarget;
    float flow = computeFlowFromError(diff, ORP_DEADBAND, orpPumpControl);

    if (flow > 0.0f) {
      int index = pumpIndexFromNumber(mqttCfg.orpPump);
      uint8_t duty = flowToDuty(orpPumpControl, flow);
      if (duty > desiredDuty[index]) desiredDuty[index] = duty;
      if (duty > 0) {
        orpActive = true;
        orpFlow = flow;
      }
    }
  }

  // Appliquer les valeurs de duty
  for (int i = 0; i < 2; ++i) {
    applyPumpDuty(i, desiredDuty[i]);
  }

  // Mettre à jour le tracking de sécurité
  if (phActive) {
    unsigned long delta = now - phDosingState.lastTimestamp;
    updateSafetyTracking(true, phFlow, delta);
  }
  if (orpActive) {
    unsigned long delta = now - orpDosingState.lastTimestamp;
    updateSafetyTracking(false, orpFlow, delta);
  }

  phDosingState.active = phActive;
  orpDosingState.active = orpActive;

  // Informer le module sensors pour la simulation
  sensors.setPhDoseActive(phActive, phFlow);
  sensors.setOrpDoseActive(orpActive, orpFlow);
}

void PumpControllerClass::stopAll() {
  applyPumpDuty(0, 0);
  applyPumpDuty(1, 0);
  systemLogger.warning("Arrêt d'urgence de toutes les pompes");
}

void PumpControllerClass::setPhPID(float kp, float ki, float kd) {
  phPID.kp = kp;
  phPID.ki = ki;
  phPID.kd = kd;
  systemLogger.info("PID pH configuré: Kp=" + String(kp) + " Ki=" + String(ki) + " Kd=" + String(kd));
}

void PumpControllerClass::setOrpPID(float kp, float ki, float kd) {
  orpPID.kp = kp;
  orpPID.ki = ki;
  orpPID.kd = kd;
  systemLogger.info("PID ORP configuré: Kp=" + String(kp) + " Ki=" + String(ki) + " Kd=" + String(kd));
}

void PumpControllerClass::resetDosingStates() {
  phDosingState = {};
  orpDosingState = {};
  phPID = {};
  orpPID = {};
  systemLogger.info("États de dosage réinitialisés");
}
