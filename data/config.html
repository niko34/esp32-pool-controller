<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Param√®tres</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: #f5f5f5;
        color: #333;
        text-align: center;
        padding: 10px;
        margin: 0;
        min-height: 100vh;
      }
      .page-title {
        color: #007aff;
        font-size: 2rem;
        font-weight: 700;
        margin: 0 0 24px;
        letter-spacing: 0.01em;
        text-align: center;
      }
      .card {
        background: white;
        display: block;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        max-width: 360px;
        margin: 20px auto;
        width: 100%;
        min-height: 600px;
      }

      /* Tablette (min 768px) */
      @media (min-width: 768px) {
        body {
          padding: 20px;
        }
        .card {
          max-width: 720px;
          padding: 25px;
          margin: 30px auto;
          min-height: 700px;
        }
      }

      /* Desktop (min 1024px) */
      @media (min-width: 1024px) {
        body {
          padding: 30px;
        }
        .card {
          max-width: 1200px;
          padding: 35px;
          margin: 40px auto;
          min-height: 800px;
        }
      }

      /* Large desktop (min 1440px) */
      @media (min-width: 1440px) {
        .card {
          max-width: 1400px;
          padding: 40px;
          min-height: 850px;
        }
      }
      .top-link {
        text-align: left;
        margin-bottom: 12px;
      }
      .top-link a {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        text-decoration: none;
        font-size: 0.95rem;
        font-weight: 500;
        color: #007aff;
        transition: color 0.2s, transform 0.2s;
        padding: 6px 10px;
        border-radius: 12px;
        background: rgba(0, 122, 255, 0.08);
      }
      .top-link a:hover {
        color: #005bb5;
        transform: translateY(-1px);
      }
      .tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 15px;
        border-radius: 8px;
      }
      .tab-button {
        flex: 1 1 calc(33.333% - 4px);
        min-width: 80px;
        padding: 10px 6px;
        border: 1px solid #d1d1d6;
        background-color: #f0f0f5;
        color: #333;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        border-radius: 6px;
      }
      .tab-button.active {
        background-color: #007aff;
        color: white;
        border-color: #007aff;
      }

      /* Tablette: tabs plus larges */
      @media (min-width: 768px) {
        .tabs {
          gap: 8px;
        }
        .tab-button {
          flex: 1 1 auto;
          min-width: 100px;
          padding: 12px 16px;
          font-size: 0.95rem;
        }
      }

      /* Desktop: tabs en ligne */
      @media (min-width: 1024px) {
        .tabs {
          flex-wrap: nowrap;
          gap: 0;
          overflow: hidden;
          border: 1px solid #d1d1d6;
        }
        .tab-button {
          flex: 1;
          padding: 12px;
          font-size: 1rem;
          border: none;
          border-radius: 0;
        }
        .tab-button + .tab-button {
          border-left: 1px solid #d1d1d6;
        }
      }
      .tab-panel {
        display: none;
        text-align: left;
      }
      .tab-panel.active {
        display: block;
      }
      .switch-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 15px;
      }
      .switch-row label {
        margin: 0;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.2s;
        border-radius: 24px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.2s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #007aff;
      }
      input:checked + .slider:before {
        transform: translateX(26px);
      }
      input {
        display: block;
        width: 100%;
        max-width: 100%;
        margin: 8px 0;
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
        border: 1px solid #d1d1d6;
        border-radius: 6px;
      }
      /* Fix pour inputs type="time" qui d√©passent sur mobile */
      input[type="time"] {
        width: 100%;
        max-width: 100%;
        -webkit-appearance: none;
        appearance: none;
      }
      select {
        display: block;
        width: 100%;
        margin: 8px 0;
        padding: 10px;
        font-size: 16px;
        box-sizing: border-box;
        border: 1px solid #d1d1d6;
        border-radius: 6px;
      }
      label {
        text-align: left;
        display: block;
        margin-top: 10px;
        margin-bottom: 4px;
        font-weight: 500;
        font-size: 0.95rem;
      }

      /* Am√©liorer espacement et taille sur grands √©crans */
      @media (min-width: 768px) {
        input, select {
          padding: 12px;
          margin: 10px 0;
        }
        label {
          font-size: 1rem;
        }
      }
      .info-block {
        margin: 10px 0;
        text-align: left;
        background-color: #f0f4ff;
        padding: 12px;
        border-radius: 8px;
        font-size: 0.9rem;
        line-height: 1.6;
      }
      .info-label {
        font-weight: 600;
        display: inline-block;
        min-width: 100px;
      }
      .actions {
        margin-top: 15px;
        text-align: right;
      }
      button {
        background-color: #007aff;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 0.95rem;
        cursor: pointer;
        border-radius: 6px;
        font-weight: 500;
        transition: background-color 0.2s, transform 0.1s;
      }
      button:hover {
        background-color: #005bb5;
        transform: translateY(-1px);
      }
      button:active {
        transform: translateY(0);
      }

      /* Am√©liorer espacement et taille sur tablette */
      @media (min-width: 768px) {
        .info-block {
          padding: 15px;
          font-size: 1rem;
        }
        .info-label {
          min-width: 120px;
        }
        button {
          padding: 12px 24px;
          font-size: 1rem;
        }
      }

      /* Ajustements mobiles */
      @media (max-width: 480px) {
        .page-title {
          font-size: 1.6rem;
        }
        .top-link a {
          font-size: 0.85rem;
        }
        .info-label {
          min-width: 80px;
          font-size: 0.85rem;
        }
      }
  </style>
</head>
<body>
    <form id="config-form" class="card">
      <div class="top-link">
        <a href="/">&#8592; Retour au tableau de bord</a>
      </div>
      <h1 class="page-title">Param√®tres</h1>
      <div class="tabs">
        <button type="button" class="tab-button active" data-tab="filtration">Filtration</button>
        <button type="button" class="tab-button" data-tab="ph">pH</button>
        <button type="button" class="tab-button" data-tab="orp">ORP</button>
        <button type="button" class="tab-button" data-tab="mqtt">MQTT</button>
        <button type="button" class="tab-button" data-tab="wifi">Wi-Fi</button>
        <button type="button" class="tab-button" data-tab="time">Horloge</button>
        <button type="button" class="tab-button" data-tab="system">Syst√®me</button>
        <button type="button" class="tab-button" data-tab="about">√Ä propos</button>
      </div>

      <div class="tab-panel active" data-tab="filtration">
        <label>Mode de filtration :</label>
        <select id="filtration_mode">
          <option value="auto">Auto</option>
          <option value="manual">Manuel</option>
          <option value="off">D√©sactiv√©</option>
        </select>

        <label>D√©but filtration :</label>
        <input type="time" id="filtration_start" value="08:00">

        <label>Fin filtration :</label>
        <input type="time" id="filtration_end" value="20:00">

        <p style="font-size: 0.85rem; color: #666; margin-top: 12px; text-align: left;">
          En mode Auto, la filtration d√©marre √† 08h au premier cycle. Apr√®s 10 min de fonctionnement,
          la temp√©rature maximale mesur√©e durant la filtration est utilis√©e pour recalculer la dur√©e (temp√©rature √∑ 2, autour de 13h).
          La nouvelle plage peut provoquer l'arr√™t imm√©diat de la filtration si l'heure recalcul√©e n'est pas encore atteinte.
        </p>
      </div>

      <div class="tab-panel" data-tab="ph">
        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h3 style="margin: 0 0 15px 0; font-size: 1rem; color: #495057;">Capteur pH</h3>
          <label>GPIO ADC1 :</label>
          <select id="ph_sensor_pin">
            <option value="-1">Pas de capteur</option>
            <option value="32">GPIO 32 (ADC1_CH4)</option>
            <option value="33">GPIO 33 (ADC1_CH5)</option>
            <option value="34">GPIO 34 (ADC1_CH6)</option>
            <option value="35">GPIO 35 (ADC1_CH7)</option>
            <option value="36">GPIO 36 (ADC1_CH0)</option>
            <option value="39">GPIO 39 (ADC1_CH3)</option>
          </select>
        </div>

        <div id="ph_calibration_section" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h3 style="margin: 0 0 15px 0; font-size: 1rem; color: #495057;">Calibration pH (DFRobot SEN0161-V2)</h3>

          <!-- Affichage des informations de calibration -->
          <div style="margin-bottom: 15px; padding: 12px; background: #e7f3ff; border-left: 4px solid #007bff; border-radius: 4px;">
            <div style="font-size: 0.85rem; color: #495057; margin-bottom: 8px; font-weight: 600;">√âtat de la calibration :</div>
            <div style="font-size: 0.85rem; line-height: 1.6;">
              <div><strong>Statut :</strong> <span id="ph_cal_status">Non calibr√©</span></div>
              <div id="ph_cal_date" style="margin-top: 4px; font-size: 0.8rem; color: #6c757d;"></div>
            </div>
          </div>

          <!-- Affichage de la valeur pH en temps r√©el -->
          <div style="margin-bottom: 15px; padding: 15px; background: #fff; border: 2px solid #6c757d; border-radius: 6px; text-align: center;">
            <div style="font-size: 0.85rem; color: #6c757d; margin-bottom: 8px; font-weight: 600;">Valeur pH actuelle :</div>
            <div id="ph_current_value" style="font-size: 2rem; font-weight: bold; color: #007bff; font-family: 'Courier New', monospace;">--</div>
            <div style="font-size: 0.75rem; color: #6c757d; margin-top: 4px;">Mise √† jour automatique toutes les 5 secondes</div>
          </div>

          <!-- Point de calibration pH 7.0 (neutre) -->
          <div style="margin-bottom: 15px; padding: 12px; background: #fff; border: 2px solid #007bff; border-radius: 6px;">
            <h4 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #007bff;">üìò Calibration pH 7.0 (neutre)</h4>
            <p style="margin: 0 0 10px 0; font-size: 0.8rem; color: #6c757d;">Plongez la sonde dans la solution tampon pH 7.0</p>
            <button type="button" id="ph_cal_neutral_btn" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Calibrer pH 7.0</button>
            <div id="ph_cal_neutral_status" style="margin-top: 8px; font-size: 0.8rem; color: #6c757d; text-align: center;">‚Äî</div>
          </div>

          <!-- Point de calibration pH 4.0 (acide) -->
          <div style="margin-bottom: 15px; padding: 12px; background: #fff; border: 2px solid #28a745; border-radius: 6px;">
            <h4 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #28a745;">üß™ Calibration pH 4.0 (acide)</h4>
            <p style="margin: 0 0 10px 0; font-size: 0.8rem; color: #6c757d;">Rincez la sonde et plongez-la dans la solution tampon pH 4.0</p>
            <button type="button" id="ph_cal_acid_btn" style="width: 100%; padding: 10px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Calibrer pH 4.0</button>
            <div id="ph_cal_acid_status" style="margin-top: 8px; font-size: 0.8rem; color: #6c757d; text-align: center;">‚Äî</div>
          </div>

          <button type="button" id="ph_cal_reset_btn" style="width: 100%; padding: 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; margin-bottom: 10px; font-size: 0.9rem;">üîÑ R√©initialiser la calibration</button>

          <div style="margin: 0; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
            <div style="font-size: 0.85rem; color: #856404; line-height: 1.6;">
              <strong>‚ö†Ô∏è Instructions importantes:</strong><br>
              1. <strong>Commencez toujours par pH 7.0</strong> (point neutre)<br>
              2. Rincez bien la sonde entre les deux calibrations<br>
              3. Attendez que la lecture se stabilise avant de calibrer<br>
              4. La temp√©rature est automatiquement compens√©e<br>
              5. Les valeurs sont sauvegard√©es en m√©moire non-volatile
            </div>
          </div>
        </div>

        <div id="ph_regulation_section" style="padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h3 style="margin: 0 0 15px 0; font-size: 1rem; color: #495057;">R√©gulation pH</h3>
          <div class="switch-row" id="ph_enable_row">
            <span>Activer la r√©gulation pH</span>
            <label class="switch">
              <input type="checkbox" id="ph_enabled">
              <span class="slider"></span>
            </label>
          </div>
          <label id="ph_target_label">pH cible :</label>
          <input type="number" id="ph_target" min="0" max="14" step="0.1" placeholder="ex: 7.2">

          <label id="ph_pump_label">Pompe utilis√©e :</label>
          <select id="ph_pump">
            <option value="1">Pompe 1</option>
            <option value="2">Pompe 2</option>
          </select>

          <label id="ph_limit_label">Dur√©e max d'injection par heure (s) :</label>
          <input type="number" id="ph_limit" min="0" step="1" value="60">
        </div>
      </div>

      <div class="tab-panel" data-tab="orp">
        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h3 style="margin: 0 0 15px 0; font-size: 1rem; color: #495057;">Capteur ORP</h3>
          <label>GPIO ADC1 :</label>
          <select id="orp_sensor_pin">
            <option value="-1">Pas de capteur</option>
            <option value="32">GPIO 32 (ADC1_CH4)</option>
            <option value="33">GPIO 33 (ADC1_CH5)</option>
            <option value="34">GPIO 34 (ADC1_CH6)</option>
            <option value="35">GPIO 35 (ADC1_CH7)</option>
            <option value="36">GPIO 36 (ADC1_CH0)</option>
            <option value="39">GPIO 39 (ADC1_CH3)</option>
          </select>
        </div>

        <div id="orp_calibration_section" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h3 style="margin: 0 0 15px 0; font-size: 1rem; color: #495057;">Calibration ORP</h3>
          <div id="orp_calibration_info" style="margin-bottom: 15px; padding: 12px; background: #e7f3ff; border-left: 4px solid #007bff; border-radius: 4px;">
            <div style="font-size: 0.85rem; color: #495057; margin-bottom: 8px; font-weight: 600;">Informations de calibration :</div>
            <div style="font-size: 0.85rem; line-height: 1.6;">
              <div><strong>Offset :</strong> <span id="orp_current_offset">Non d√©fini</span></div>
              <div><strong>Slope :</strong> <span id="orp_current_slope">1.0</span></div>
              <div><strong>R√©f√©rence :</strong> <span id="orp_calibration_reference">‚Äî</span></div>
              <div><strong>Date :</strong> <span id="orp_calibration_date">‚Äî</span></div>
            </div>
          </div>

          <!-- Affichage de la valeur ORP en temps r√©el -->
          <div style="margin-bottom: 15px; padding: 15px; background: #fff; border: 2px solid #6c757d; border-radius: 6px; text-align: center;">
            <div style="font-size: 0.85rem; color: #6c757d; margin-bottom: 8px; font-weight: 600;">Valeur ORP actuelle :</div>
            <div id="orp_current_value" style="font-size: 2rem; font-weight: bold; color: #007bff; font-family: 'Courier New', monospace;">--</div>
            <div style="font-size: 0.75rem; color: #6c757d; margin-top: 4px;">Mise √† jour automatique toutes les 5 secondes</div>
          </div>

          <!-- Choix du type de calibration -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Type de calibration :</label>
            <select id="orp_cal_type" style="width: 100%; padding: 8px;">
              <option value="1point">1 point (offset seul)</option>
              <option value="2points">2 points (offset + slope)</option>
            </select>
          </div>

          <!-- Calibration 1 point -->
          <div id="orp_cal_1point" style="display: block;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
              <label style="flex: 0 0 auto; margin: 0;">Valeur de r√©f√©rence (mV) :</label>
              <input type="number" id="orp_reference_value" min="0" max="1000" step="1" placeholder="ex: 650" style="flex: 1; min-width: 0;">
            </div>
            <button type="button" id="orp_calibrate_btn" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; margin-bottom: 10px;">Calibrer (1 point)</button>
            <p style="margin: 0; font-size: 0.85rem; color: #6c757d;">
              Plongez la sonde dans une solution de r√©f√©rence, entrez sa valeur ORP connue en mV, puis cliquez sur Calibrer.
            </p>
          </div>

          <!-- Calibration 2 points -->
          <div id="orp_cal_2points" style="display: none;">
            <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
              <p style="margin: 0; font-size: 0.85rem; line-height: 1.5;">
                <strong>üìã √âtapes :</strong><br>
                1. Plongez la sonde dans la <strong>premi√®re</strong> solution de r√©f√©rence<br>
                2. Notez la valeur ORP affich√©e et entrez la valeur de r√©f√©rence<br>
                3. Cliquez sur "M√©moriser Point 1"<br>
                4. Rincez la sonde, plongez dans la <strong>deuxi√®me</strong> solution<br>
                5. Entrez la valeur de r√©f√©rence et cliquez sur "Calibrer (2 points)"
              </p>
            </div>

            <div style="margin-bottom: 15px; padding: 10px; background: #e7f3ff; border-radius: 4px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 5px;">Point 1 :</div>
              <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="number" id="orp_ref1" min="0" max="1000" step="1" placeholder="R√©f. 1 (ex: 470)" style="flex: 1;">
                <button type="button" id="orp_save_point1_btn" style="padding: 8px 15px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">M√©moriser Point 1</button>
              </div>
              <div style="font-size: 0.8rem; color: #6c757d;">
                <span id="orp_point1_status">En attente...</span>
              </div>
            </div>

            <div style="margin-bottom: 15px; padding: 10px; background: #e7f3ff; border-radius: 4px;">
              <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 5px;">Point 2 :</div>
              <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="number" id="orp_ref2" min="0" max="1000" step="1" placeholder="R√©f. 2 (ex: 650)" style="flex: 1;">
              </div>
            </div>

            <button type="button" id="orp_calibrate_2points_btn" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; margin-bottom: 10px;" disabled>Calibrer (2 points)</button>
            <p style="margin: 0; font-size: 0.85rem; color: #6c757d;">
              Recommandation : Utilisez 2 solutions espac√©es (ex: 470 mV et 650 mV) pour une meilleure pr√©cision.
            </p>
          </div>
        </div>

        <div id="orp_regulation_section" style="padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h3 style="margin: 0 0 15px 0; font-size: 1rem; color: #495057;">R√©gulation ORP</h3>
          <div class="switch-row" id="orp_enable_row">
            <span>Activer la r√©gulation ORP</span>
            <label class="switch">
              <input type="checkbox" id="orp_enabled">
              <span class="slider"></span>
            </label>
          </div>
          <label id="orp_target_label">ORP cible (mV) :</label>
          <input type="number" id="orp_target" min="0" max="1000" step="1" placeholder="ex: 650">

          <label id="orp_pump_label">Pompe utilis√©e :</label>
          <select id="orp_pump">
            <option value="1">Pompe 1</option>
            <option value="2">Pompe 2</option>
          </select>

          <label id="orp_limit_label">Dur√©e max d'injection par heure (s) :</label>
          <input type="number" id="orp_limit" min="0" step="1" value="60">
        </div>
      </div>

      <div class="tab-panel" data-tab="mqtt">
        <div style="margin-bottom: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="font-weight: 500;">Activer la publication MQTT</span>
            <label class="switch">
              <input type="checkbox" id="mqtt_enabled">
              <span class="slider"></span>
            </label>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="font-weight: 500; color: #6c757d;">Statut:</span>
            <span id="mqtt_status_indicator" style="display: inline-block; width: 14px; height: 14px; border-radius: 50%; background-color: #999; box-shadow: 0 0 4px rgba(0,0,0,0.2);" title="Statut MQTT"></span>
          </div>
        </div>

        <label>Serveur MQTT :</label>
        <input type="text" id="mqtt_server" placeholder="ex: 192.168.1.10">

        <label>Port :</label>
        <input type="number" id="mqtt_port" placeholder="1883" value="1883">

        <label>Topic :</label>
        <input type="text" id="mqtt_topic" placeholder="ex: home/pool/data">

        <label>Login :</label>
        <input type="text" id="mqtt_username" placeholder="ex: utilisateur">

        <label>Mot de passe :</label>
        <input type="password" id="mqtt_password" placeholder="ex: ********">
      </div>

      <div class="tab-panel" data-tab="wifi">
        <div class="info-block">
          <div><span class="info-label">R√©seau : </span><span id="wifi_ssid">?</span></div>
          <div><span class="info-label">Adresse IP : </span><span id="wifi_ip">?</span></div>
          <div><span class="info-label">Mode : </span><span id="wifi_mode">?</span></div>
          <div><span class="info-label">Adresse mDNS :</span><span id="wifi_mdns">poolcontroller.local</span></div>
        </div>
        <button type="button" id="restart-ap-btn" style="width:100%;">Red√©marrer en mode AP</button>
      </div>

      <div class="tab-panel" data-tab="time">
        <div class="switch-row">
          <span>Synchroniser via NTP</span>
          <label class="switch">
            <input type="checkbox" id="time_use_ntp">
            <span class="slider"></span>
          </label>
        </div>

        <div id="timezone_row" style="display:none;">
          <label>Fuseau horaire :</label>
          <select id="time_timezone">
            <option value="europe_paris">Europe/Paris (UTC+1/UTC+2)</option>
            <option value="utc">UTC</option>
            <option value="america_new_york">America/New_York (UTC-5/UTC-4)</option>
            <option value="america_los_angeles">America/Los_Angeles (UTC-8/UTC-7)</option>
            <option value="asia_tokyo">Asia/Tokyo (UTC+9)</option>
            <option value="australia_sydney">Australia/Sydney (UTC+10/UTC+11)</option>
          </select>
        </div>

        <label>Serveur NTP :</label>
        <input type="text" id="time_ntp_server" placeholder="pool.ntp.org">

        <label>Heure :</label>
        <input type="datetime-local" id="time_manual">

        <div class="info-block" id="time_info" style="display:none;">
          <div><span class="info-label">Heure actuelle :</span><span id="time_current">‚Äî</span></div>
        </div>
      </div>

      <!-- Onglet Syst√®me -->
      <div class="tab-panel" data-tab="system">
        <h3>Informations Syst√®me</h3>

        <div class="info-block">
          <div><span class="info-label">Version firmware :</span><span id="sys_firmware_version">‚Äî</span></div>
          <div><span class="info-label">Build :</span><span id="sys_build_date">‚Äî</span></div>
          <div><span class="info-label">Uptime :</span><span id="sys_uptime">‚Äî</span></div>
        </div>

        <div class="info-block">
          <div><span class="info-label">Mod√®le puce :</span><span id="sys_chip_model">‚Äî</span></div>
          <div><span class="info-label">Fr√©quence CPU :</span><span id="sys_cpu_freq">‚Äî</span></div>
          <div><span class="info-label">M√©moire libre :</span><span id="sys_free_heap">‚Äî</span></div>
          <div><span class="info-label">Taille flash :</span><span id="sys_flash_size">‚Äî</span></div>
        </div>

        <div class="info-block">
          <div><span class="info-label">Syst√®me fichiers :</span><span id="sys_fs_usage">‚Äî</span></div>
          <div><span class="info-label">WiFi RSSI :</span><span id="sys_wifi_rssi">‚Äî</span></div>
          <div><span class="info-label">Adresse MAC :</span><span id="sys_mac_address">‚Äî</span></div>
        </div>

        <h3 style="margin-top: 24px;">Mise √† jour OTA</h3>

        <div class="info-block" style="background-color: #fff4e6; border-left: 4px solid #ff9500;">
          <p style="margin: 0; font-size: 0.9rem;">
            ‚ö†Ô∏è <strong>Attention :</strong> Ne coupez pas l'alimentation pendant la mise √† jour.
          </p>
        </div>

        <label>Type de mise √† jour :</label>
        <select id="update_type">
          <option value="firmware">Firmware (.bin)</option>
          <option value="filesystem">Syst√®me de fichiers (.littlefs.bin)</option>
        </select>

        <label>Fichier de mise √† jour :</label>
        <input type="file" id="update_file" accept=".bin" style="border: 2px dashed #d1d1d6; padding: 20px; text-align: center; cursor: pointer;">

        <div id="update_progress" style="display:none; margin-top: 15px;">
          <div style="background-color: #f0f0f5; border-radius: 10px; overflow: hidden; height: 30px;">
            <div id="update_progress_bar" style="background-color: #007aff; height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.9rem;">
              0%
            </div>
          </div>
          <p id="update_status" style="margin-top: 8px; text-align: center; font-size: 0.9rem; color: #666;">
            Pr√©paration...
          </p>
        </div>

        <div class="actions">
          <button type="button" id="update_btn" disabled style="background-color: #34c759;">Mettre √† jour</button>
          <button type="button" id="refresh_info_btn" style="background-color: #666; margin-left: 10px;">Actualiser</button>
        </div>

        <h3 style="margin-top: 24px;">Test des Pompes</h3>

        <div class="info-block" style="background-color: #fff4e6; border-left: 4px solid #ff9500;">
          <p style="margin: 0; font-size: 0.9rem;">
            ‚ö†Ô∏è <strong>Attention :</strong> Ces commandes permettent de tester manuellement les pompes. Utilisez avec pr√©caution.
          </p>
        </div>

        <div class="switch-row">
          <span>Pompe 1 (Test manuel)</span>
          <label class="switch">
            <input type="checkbox" id="pump1_test">
            <span class="slider"></span>
          </label>
        </div>
        <div style="margin-left: 20px; margin-bottom: 20px;">
          <label for="pump1_duty" style="display: block; margin-bottom: 5px; color: #666; font-size: 0.9rem;">
            Puissance: <span id="pump1_duty_value">100</span>% (PWM: <span id="pump1_duty_pwm">255</span>/255)
          </label>
          <input type="range" id="pump1_duty" min="0" max="255" value="255"
                 style="width: 100%; max-width: 400px;">
        </div>

        <div class="switch-row">
          <span>Pompe 2 (Test manuel)</span>
          <label class="switch">
            <input type="checkbox" id="pump2_test">
            <span class="slider"></span>
          </label>
        </div>
        <div style="margin-left: 20px; margin-bottom: 20px;">
          <label for="pump2_duty" style="display: block; margin-bottom: 5px; color: #666; font-size: 0.9rem;">
            Puissance: <span id="pump2_duty_value">100</span>% (PWM: <span id="pump2_duty_pwm">255</span>/255)
          </label>
          <input type="range" id="pump2_duty" min="0" max="255" value="255"
                 style="width: 100%; max-width: 400px;">
        </div>

        <h3 style="margin-top: 24px;">Logs Syst√®me</h3>

        <div class="actions" style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
          <button type="button" id="refresh_logs_btn" style="background-color: #007aff;">Actualiser les logs</button>
          <button type="button" id="clear_logs_display_btn" style="background-color: #666;">Effacer l'affichage</button>

          <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
            <label for="logs_filter" style="color: #333; font-weight: 500;">Filtre:</label>
            <select id="logs_filter" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; background-color: white; font-size: 0.9rem;">
              <option value="all">Tout</option>
              <option value="temp">Temp√©rature</option>
              <option value="ph">pH</option>
              <option value="orp">ORP</option>
            </select>
          </div>
        </div>

        <div id="logs_container" style="background-color: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.85rem; max-height: 400px; overflow-y: auto; line-height: 1.5;">
          <div id="logs_content">Chargement des logs...</div>
        </div>
      </div>

      <!-- Onglet √Ä propos -->
      <div class="tab-panel" data-tab="about">
        <h3 style="margin-bottom: 20px; color: #007aff;">ESP32 Pool Controller</h3>

        <div class="info-block" style="margin-bottom: 20px;">
          <p style="font-size: 1rem; line-height: 1.6; margin-bottom: 15px;">
            Contr√¥leur automatique de piscine bas√© sur ESP32 avec gestion pH, ORP (chlore),
            temp√©rature et filtration automatique. Int√©gration compl√®te avec Home Assistant via MQTT.
          </p>
          <div style="margin-top: 15px;">
            <span class="info-label">Version :</span>
            <span id="about_version" style="font-weight: 600; color: #007aff;">2025.12.6</span>
          </div>
          <div style="margin-top: 10px;">
            <span class="info-label">GitHub :</span>
            <a href="https://github.com/niko34/esp32-pool-controller" target="_blank"
               style="color: #007aff; text-decoration: none; font-weight: 500;">
              github.com/niko34/esp32-pool-controller
            </a>
          </div>
          <div style="margin-top: 10px;">
            <span class="info-label">Auteur :</span>
            <span>Nicolas Philippe</span>
          </div>
          <div style="margin-top: 10px;">
            <span class="info-label">Licence :</span>
            <span>MIT License</span>
          </div>
        </div>

        <h3 style="margin-top: 30px; margin-bottom: 15px;">Librairies utilis√©es</h3>

        <div class="info-block" style="margin-bottom: 15px;">
          <h4 style="margin-bottom: 10px; font-size: 1rem; color: #333;">Framework & R√©seau</h4>
          <div style="margin-left: 15px; line-height: 1.8;">
            <div>‚Ä¢ <strong>ESP32 Arduino Core</strong> - Framework Arduino pour ESP32</div>
            <div>‚Ä¢ <strong>AsyncTCP</strong> - Biblioth√®que TCP asynchrone par me-no-dev</div>
            <div>‚Ä¢ <strong>ESPAsyncWebServer</strong> - Serveur web asynchrone par me-no-dev</div>
            <div>‚Ä¢ <strong>ESPAsyncWiFiManager</strong> - Gestionnaire WiFi par alanswx</div>
            <div>‚Ä¢ <strong>PubSubClient</strong> - Client MQTT par Nick O'Leary</div>
          </div>
        </div>

        <div class="info-block" style="margin-bottom: 15px;">
          <h4 style="margin-bottom: 10px; font-size: 1rem; color: #333;">Capteurs & Mesures</h4>
          <div style="margin-left: 15px; line-height: 1.8;">
            <div>‚Ä¢ <strong>DFRobot_PH</strong> - Biblioth√®que capteur pH DFRobot SEN0161-V2</div>
            <div>‚Ä¢ <strong>Adafruit ADS1X15</strong> - Convertisseur ADC 16-bit I2C par Adafruit</div>
            <div>‚Ä¢ <strong>DallasTemperature</strong> - Sondes de temp√©rature DS18B20</div>
            <div>‚Ä¢ <strong>OneWire</strong> - Protocol OneWire pour DS18B20</div>
          </div>
        </div>

        <div class="info-block">
          <h4 style="margin-bottom: 10px; font-size: 1rem; color: #333;">Utilitaires</h4>
          <div style="margin-left: 15px; line-height: 1.8;">
            <div>‚Ä¢ <strong>ArduinoJson</strong> - Biblioth√®que JSON par Beno√Æt Blanchon</div>
            <div>‚Ä¢ <strong>LittleFS</strong> - Syst√®me de fichiers pour ESP32</div>
            <div>‚Ä¢ <strong>ESPmDNS</strong> - R√©solution DNS multicast (.local)</div>
            <div>‚Ä¢ <strong>ArduinoOTA</strong> - Mise √† jour Over-The-Air</div>
          </div>
        </div>

        <p style="margin-top: 30px; padding: 15px; background-color: #f0f4ff; border-left: 4px solid #007aff; border-radius: 4px; font-size: 0.9rem; line-height: 1.6;">
          <strong>‚ö†Ô∏è Avertissement :</strong> Ce projet est fourni "tel quel" sans garantie.
          L'utilisation de produits chimiques et d'√©quipements √©lectriques pr√®s de l'eau pr√©sente des risques.
          L'utilisateur est seul responsable de la conformit√© aux r√©glementations locales,
          de la s√©curit√© de l'installation et du bon dosage des produits chimiques.
        </p>
      </div>
    </form>

    <script>
      // Charger la config actuelle
      const toggle = document.getElementById('mqtt_enabled');
      const tabButtons = document.querySelectorAll('.tab-button');
      const panels = document.querySelectorAll('.tab-panel');
      const phInput = document.getElementById('ph_target');
      const orpInput = document.getElementById('orp_target');
      const phToggle = document.getElementById('ph_enabled');
      const orpToggle = document.getElementById('orp_enabled');
      const phPumpSelect = document.getElementById('ph_pump');
      const orpPumpSelect = document.getElementById('orp_pump');
      const phLimitInput = document.getElementById('ph_limit');
      const orpLimitInput = document.getElementById('orp_limit');
      const filtrationMode = document.getElementById('filtration_mode');
      const filtrationStart = document.getElementById('filtration_start');
      const filtrationEnd = document.getElementById('filtration_end');
      const wifiSsidEl = document.getElementById('wifi_ssid');
      const wifiIpEl = document.getElementById('wifi_ip');
      const wifiModeEl = document.getElementById('wifi_mode');
      const wifiMdnsEl = document.getElementById('wifi_mdns');
      const restartApBtn = document.getElementById('restart-ap-btn');
      const timeUseNtp = document.getElementById('time_use_ntp');
      const timeNtpServer = document.getElementById('time_ntp_server');
      const timeManualInput = document.getElementById('time_manual');
      const timeInfo = document.getElementById('time_info');
      const timeCurrentLabel = document.getElementById('time_current');
      const timezoneRow = document.getElementById('timezone_row');
      const timeTimezone = document.getElementById('time_timezone');
      const phSensorPin = document.getElementById('ph_sensor_pin');
      const orpSensorPin = document.getElementById('orp_sensor_pin');

      // √âl√©ments calibration pH
      // Calibration pH (DFRobot SEN0161-V2)
      const phCalNeutralBtn = document.getElementById('ph_cal_neutral_btn');
      const phCalNeutralStatus = document.getElementById('ph_cal_neutral_status');
      const phCalAcidBtn = document.getElementById('ph_cal_acid_btn');
      const phCalAcidStatus = document.getElementById('ph_cal_acid_status');
      const phCalResetBtn = document.getElementById('ph_cal_reset_btn');
      const phCalStatus = document.getElementById('ph_cal_status');
      const phCalDate = document.getElementById('ph_cal_date');
      const phCurrentValue = document.getElementById('ph_current_value');

      // √âl√©ments calibration ORP
      const orpReferenceValue = document.getElementById('orp_reference_value');
      const orpCalibrateBtn = document.getElementById('orp_calibrate_btn');
      const orpCurrentValue = document.getElementById('orp_current_value');
      const orpCalType = document.getElementById('orp_cal_type');
      const orpCal1Point = document.getElementById('orp_cal_1point');
      const orpCal2Points = document.getElementById('orp_cal_2points');
      const orpRef1 = document.getElementById('orp_ref1');
      const orpRef2 = document.getElementById('orp_ref2');
      const orpSavePoint1Btn = document.getElementById('orp_save_point1_btn');
      const orpCalibrate2PointsBtn = document.getElementById('orp_calibrate_2points_btn');
      const orpPoint1Status = document.getElementById('orp_point1_status');

      // Variables pour calibration 2 points
      let orpPoint1Measured = null;
      let orpPoint1Reference = null;

      const phCalibrationSection = document.getElementById('ph_calibration_section');
      const orpCalibrationSection = document.getElementById('orp_calibration_section');
      const phRegulationSection = document.getElementById('ph_regulation_section');
      const orpRegulationSection = document.getElementById('orp_regulation_section');
      let cachedManualTime = '';
      let timeRefreshTimer = null;
      let cachedManualStart = filtrationStart.value;
      let cachedManualEnd = filtrationEnd.value;

      // DFRobot_PH g√®re la calibration automatiquement - plus besoin de mode

      function updateFiltrationControls(applyCache = false) {
        const mode = filtrationMode.value;
        const isManual = mode === 'manual';
        const disabled = !isManual;
        filtrationStart.disabled = disabled;
        filtrationEnd.disabled = disabled;
        filtrationStart.readOnly = disabled;
        filtrationEnd.readOnly = disabled;
        if (isManual && applyCache) {
          filtrationStart.value = cachedManualStart;
          filtrationEnd.value = cachedManualEnd;
        }
      }

      function updatePhControls() {
        const noSensor = phSensorPin.value === '-1';
        phToggle.disabled = noSensor;
        if (noSensor) {
          phToggle.checked = false;
        }
        const disabled = noSensor || !phToggle.checked;
        phInput.disabled = disabled;
        phPumpSelect.disabled = disabled;
        phLimitInput.disabled = disabled;
        // Calibration and Regulation section visibility
        phCalibrationSection.style.display = noSensor ? 'none' : 'block';
        phRegulationSection.style.display = noSensor ? 'none' : 'block';
        // Grisage visuel
        const enableRowOpacity = noSensor ? '0.5' : '1';
        const fieldsOpacity = disabled ? '0.5' : '1';
        document.getElementById('ph_enable_row').style.opacity = enableRowOpacity;
        document.getElementById('ph_target_label').style.opacity = fieldsOpacity;
        phInput.style.opacity = fieldsOpacity;
        document.getElementById('ph_pump_label').style.opacity = fieldsOpacity;
        phPumpSelect.style.opacity = fieldsOpacity;
        document.getElementById('ph_limit_label').style.opacity = fieldsOpacity;
        phLimitInput.style.opacity = fieldsOpacity;
      }

      function updateOrpControls() {
        const noSensor = orpSensorPin.value === '-1';
        orpToggle.disabled = noSensor;
        if (noSensor) {
          orpToggle.checked = false;
        }
        const disabled = noSensor || !orpToggle.checked;
        orpInput.disabled = disabled;
        orpPumpSelect.disabled = disabled;
        orpLimitInput.disabled = disabled;
        // Calibration and Regulation section visibility
        orpCalibrationSection.style.display = noSensor ? 'none' : 'block';
        orpRegulationSection.style.display = noSensor ? 'none' : 'block';
        // Grisage visuel
        const enableRowOpacity = noSensor ? '0.5' : '1';
        const fieldsOpacity = disabled ? '0.5' : '1';
        document.getElementById('orp_enable_row').style.opacity = enableRowOpacity;
        document.getElementById('orp_target_label').style.opacity = fieldsOpacity;
        orpInput.style.opacity = fieldsOpacity;
        document.getElementById('orp_pump_label').style.opacity = fieldsOpacity;
        orpPumpSelect.style.opacity = fieldsOpacity;
        document.getElementById('orp_limit_label').style.opacity = fieldsOpacity;
        orpLimitInput.style.opacity = fieldsOpacity;
      }

      function refreshTimeNow() {
        fetch('/time-now')
          .then(res => res.json())
          .then(data => {
            if (data.time) {
              timeCurrentLabel.textContent = data.time.replace('T', ' ');
              if (timeUseNtp.checked) {
                timeManualInput.value = data.time;
              }
            }
          })
          .catch(() => {});
      }

      function startTimeRefresh() {
        if (timeRefreshTimer) {
          clearInterval(timeRefreshTimer);
          timeRefreshTimer = null;
        }
        if (timeUseNtp.checked) {
          refreshTimeNow();
          timeRefreshTimer = setInterval(refreshTimeNow, 60000);
        } else {
          const value = timeManualInput.value;
          timeCurrentLabel.textContent = value ? value.replace('T', ' ') : '‚Äî';
        }
      }

      function updateTimeControls(currentTimeValue) {
        const useNtp = timeUseNtp.checked;
        timezoneRow.style.display = useNtp ? 'block' : 'none';
        timeTimezone.disabled = !useNtp;
        timeManualInput.disabled = useNtp;
        timeManualInput.readOnly = useNtp;
        timeInfo.style.display = useNtp ? 'block' : 'none';
        if (useNtp) {
          if (!cachedManualTime) {
            cachedManualTime = timeManualInput.value;
          }
          if (currentTimeValue) {
            timeManualInput.value = currentTimeValue;
            timeCurrentLabel.textContent = currentTimeValue.replace('T', ' ');
          } else if (timeManualInput.value) {
            timeCurrentLabel.textContent = timeManualInput.value.replace('T', ' ');
          } else {
            timeCurrentLabel.textContent = '‚Äî';
          }
        } else {
          if (cachedManualTime) {
            timeManualInput.value = cachedManualTime;
          }
          const value = timeManualInput.value;
          timeCurrentLabel.textContent = value ? value.replace('T', ' ') : '‚Äî';
        }
        startTimeRefresh();
      }

      // Fonction pour obtenir l'onglet actif actuel
      function getCurrentActiveTab() {
        const activeButton = document.querySelector('.tab-button.active');
        return activeButton ? activeButton.dataset.tab : 'filtration';
      }

      // Fonction pour activer un onglet sp√©cifique
      function setActiveTab(tabName) {
        tabButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
        panels.forEach(panel => panel.classList.toggle('active', panel.dataset.tab === tabName));
      }

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const target = button.dataset.tab;
          setActiveTab(target);
        });
      });

      function collectConfig() {
        const portValue = parseInt(document.getElementById('mqtt_port').value, 10);
        const phValue = parseFloat(phInput.value);
        const orpValue = parseFloat(orpInput.value);
        const phPumpValue = parseInt(phPumpSelect.value, 10);
        const orpPumpValue = parseInt(orpPumpSelect.value, 10);
        const phLimitValue = parseInt(phLimitInput.value, 10);
        const orpLimitValue = parseInt(orpLimitInput.value, 10);
        const manualTimeValue = timeManualInput.value;
        const modeValue = filtrationMode.value;
        let startValue = filtrationStart.value;
        let endValue = filtrationEnd.value;
        if (modeValue !== 'manual') {
          startValue = filtrationStart.value;
          endValue = filtrationEnd.value;
        }
        return {
          enabled: toggle.checked,
          server: document.getElementById('mqtt_server').value,
          port: isNaN(portValue) ? 1883 : portValue,
          topic: document.getElementById('mqtt_topic').value,
          username: document.getElementById('mqtt_username').value,
          password: document.getElementById('mqtt_password').value,
          ph_target: isNaN(phValue) ? 7.2 : phValue,
          orp_target: isNaN(orpValue) ? 650 : orpValue,
          ph_enabled: phToggle.checked,
          ph_pump: isNaN(phPumpValue) ? 1 : phPumpValue,
          orp_enabled: orpToggle.checked,
          orp_pump: isNaN(orpPumpValue) ? 2 : orpPumpValue,
          ph_limit_seconds: isNaN(phLimitValue) ? 60 : phLimitValue,
          orp_limit_seconds: isNaN(orpLimitValue) ? 60 : orpLimitValue,
          ph_sensor_pin: parseInt(phSensorPin.value, 10),
          orp_sensor_pin: parseInt(orpSensorPin.value, 10),
          time_use_ntp: timeUseNtp.checked,
          ntp_server: timeNtpServer.value || 'pool.ntp.org',
          manual_time: manualTimeValue,
          timezone_id: timeTimezone.value || 'europe_paris',
          filtration_mode: modeValue,
          filtration_start: startValue,
          filtration_end: endValue
        };
      }

      function sendConfig(data) {
        fetch('/save-config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
      }

      // Variable globale pour stocker les donn√©es actuelles des capteurs
      let latestSensorData = null;

      // Fonction pour charger les donn√©es des capteurs
      function loadSensorData() {
        fetch('/data')
          .then(res => res.json())
          .then(data => {
            latestSensorData = data;
            console.log('[SENSOR DATA] Loaded:', data);

            // Mettre √† jour l'affichage de la valeur pH actuelle
            if (phCurrentValue) {
              if (data.ph !== null && data.ph !== undefined && typeof data.ph === 'number' && !isNaN(data.ph)) {
                phCurrentValue.textContent = data.ph.toFixed(2);
                // Changer la couleur selon la valeur pH
                if (data.ph < 6.8) {
                  phCurrentValue.style.color = '#dc3545'; // Rouge (acide)
                } else if (data.ph > 7.8) {
                  phCurrentValue.style.color = '#ffc107'; // Orange (basique)
                } else {
                  phCurrentValue.style.color = '#28a745'; // Vert (optimal)
                }
              } else {
                phCurrentValue.textContent = '--';
                phCurrentValue.style.color = '#6c757d';
              }
            }

            // Mettre √† jour l'affichage de la valeur ORP actuelle
            if (orpCurrentValue) {
              if (data.orp !== null && data.orp !== undefined && typeof data.orp === 'number' && !isNaN(data.orp)) {
                orpCurrentValue.textContent = Math.round(data.orp) + ' mV';
                // Changer la couleur selon la valeur ORP
                if (data.orp < 650) {
                  orpCurrentValue.style.color = '#dc3545'; // Rouge (trop bas)
                } else if (data.orp > 750) {
                  orpCurrentValue.style.color = '#ffc107'; // Orange (trop haut)
                } else {
                  orpCurrentValue.style.color = '#28a745'; // Vert (optimal)
                }
              } else {
                orpCurrentValue.textContent = '--';
                orpCurrentValue.style.color = '#6c757d';
              }
            }
          })
          .catch(err => {
            console.error('[SENSOR DATA] Error loading:', err);
            if (phCurrentValue) {
              phCurrentValue.textContent = 'Erreur';
              phCurrentValue.style.color = '#dc3545';
            }
            if (orpCurrentValue) {
              orpCurrentValue.textContent = 'Erreur';
              orpCurrentValue.style.color = '#dc3545';
            }
          });
      }

      // Charger les donn√©es au d√©marrage
      loadSensorData();

      // Rafra√Æchir les donn√©es toutes les 2 secondes (utile pour la calibration)
      setInterval(loadSensorData, 2000);

      // Fonction pour mettre √† jour la pastille de statut MQTT
      function updateMqttStatusIndicator(enabled, connected) {
        const indicator = document.getElementById('mqtt_status_indicator');
        if (!indicator) return;

        if (!enabled) {
          // MQTT d√©sactiv√© ‚Üí pastille grise
          indicator.style.backgroundColor = '#999';
          indicator.title = 'MQTT d√©sactiv√©';
        } else if (connected) {
          // MQTT activ√© et connect√© ‚Üí pastille verte
          indicator.style.backgroundColor = '#28a745';
          indicator.title = 'MQTT connect√©';
        } else {
          // MQTT activ√© mais non connect√© ‚Üí pastille rouge
          indicator.style.backgroundColor = '#dc3545';
          indicator.title = 'MQTT non connect√©';
        }
      }

      // Fonction pour charger la configuration
      function loadConfig() {
        return fetch('/get-config')
        .then(res => res.json())
        .then(cfg => {
          document.getElementById('mqtt_server').value = cfg.server || '';
          document.getElementById('mqtt_port').value = cfg.port || 1883;
          document.getElementById('mqtt_topic').value = cfg.topic || '';
          document.getElementById('mqtt_username').value = cfg.username || '';
          document.getElementById('mqtt_password').value = cfg.password || '';
          toggle.checked = cfg.enabled !== false;

          // Mise √† jour de la pastille de statut MQTT
          updateMqttStatusIndicator(cfg.enabled, cfg.mqtt_connected);
          phInput.value = (typeof cfg.ph_target === 'number') ? cfg.ph_target : 7.2;
          orpInput.value = (typeof cfg.orp_target === 'number') ? cfg.orp_target : 650;
          phToggle.checked = cfg.ph_enabled === true;
          phPumpSelect.value = (cfg.ph_pump === 2 ? '2' : '1');
          orpToggle.checked = cfg.orp_enabled === true;
          orpPumpSelect.value = (cfg.orp_pump === 1 ? '1' : '2');
          phLimitInput.value = (typeof cfg.ph_limit_seconds === 'number') ? cfg.ph_limit_seconds : 60;
          orpLimitInput.value = (typeof cfg.orp_limit_seconds === 'number') ? cfg.orp_limit_seconds : 60;
          phSensorPin.value = (typeof cfg.ph_sensor_pin === 'number') ? cfg.ph_sensor_pin.toString() : '35';
          orpSensorPin.value = (typeof cfg.orp_sensor_pin === 'number') ? cfg.orp_sensor_pin.toString() : '34';

          // Afficher les informations de calibration pH (DFRobot SEN0161-V2)
          const phCalValid = cfg.ph_cal_valid === true;
          const phCalibrationDate = cfg.ph_calibration_date || '';
          const phCalibrationTemp = cfg.ph_calibration_temp;

          if (phCalStatus) {
            if (phCalValid) {
              phCalStatus.textContent = 'Calibr√© ‚úì';
              phCalStatus.style.color = '#28a745';
              phCalStatus.style.fontWeight = '600';
            } else {
              phCalStatus.textContent = 'Non calibr√©';
              phCalStatus.style.color = '#dc3545';
              phCalStatus.style.fontWeight = '500';
            }
          }

          if (phCalDate && phCalibrationDate) {
            const date = new Date(phCalibrationDate);
            let dateInfo = 'Derni√®re calibration : ' + date.toLocaleDateString('fr-FR', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
            if (phCalibrationTemp && !isNaN(phCalibrationTemp)) {
              dateInfo += ` (${phCalibrationTemp.toFixed(1)}¬∞C)`;
            }
            phCalDate.textContent = dateInfo;
          }

          // Calibration ORP
          const orpOffsetEl = document.getElementById('orp_current_offset');
          const orpSlopeEl = document.getElementById('orp_current_slope');

          // Afficher les informations compl√®tes de calibration ORP
          const orpCalibrated = cfg.orp_calibration_date && cfg.orp_calibration_date !== '';

          if (orpOffsetEl) {
            const orpOffset = cfg.orp_calibration_offset || 0;
            if (!orpCalibrated) {
              orpOffsetEl.textContent = 'Non calibr√©';
              orpOffsetEl.style.color = '#dc3545';
              orpOffsetEl.style.fontWeight = '500';
            } else if (orpOffset === 0) {
              orpOffsetEl.textContent = 'Aucun (0.0 mV)';
              orpOffsetEl.style.color = '#6c757d';
              orpOffsetEl.style.fontWeight = 'normal';
            } else {
              orpOffsetEl.textContent = `${orpOffset >= 0 ? '+' : ''}${orpOffset.toFixed(1)} mV`;
              orpOffsetEl.style.color = '#007bff';
              orpOffsetEl.style.fontWeight = 'normal';
            }
          }

          if (orpSlopeEl) {
            const orpSlope = cfg.orp_calibration_slope || 1.0;
            orpSlopeEl.textContent = orpSlope.toFixed(3);
            if (Math.abs(orpSlope - 1.0) < 0.001) {
              orpSlopeEl.style.color = '#6c757d';
            } else {
              orpSlopeEl.style.color = '#007bff';
            }
          }

          const orpRefEl = document.getElementById('orp_calibration_reference');
          if (orpRefEl) {
            if (!orpCalibrated) {
              orpRefEl.textContent = 'Non calibr√©';
              orpRefEl.style.color = '#dc3545';
              orpRefEl.style.fontWeight = '500';
            } else {
              const ref = cfg.orp_calibration_reference;
              orpRefEl.textContent = (ref && ref > 0) ? `${ref.toFixed(0)} mV` : '‚Äî';
              orpRefEl.style.color = '';
              orpRefEl.style.fontWeight = 'normal';
            }
          }

          const orpDateEl = document.getElementById('orp_calibration_date');
          if (orpDateEl) {
            if (!orpCalibrated) {
              orpDateEl.textContent = 'Non calibr√©';
              orpDateEl.style.color = '#dc3545';
              orpDateEl.style.fontWeight = '500';
            } else {
              const dateStr = cfg.orp_calibration_date;
              const date = new Date(dateStr);
              const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
              orpDateEl.textContent = date.toLocaleDateString('fr-FR', options);
              orpDateEl.style.color = '';
              orpDateEl.style.fontWeight = 'normal';
            }
          }

          updatePhControls();
          updateOrpControls();
          timeUseNtp.checked = cfg.time_use_ntp !== false;
          timeNtpServer.value = cfg.ntp_server || 'pool.ntp.org';
          const manualValue = cfg.manual_time || '';
          cachedManualTime = manualValue;
          timeManualInput.value = manualValue;
          const tzValue = cfg.timezone_id || 'europe_paris';
          if (timeTimezone.querySelector(`option[value="${tzValue}"]`)) {
            timeTimezone.value = tzValue;
          } else {
            timeTimezone.value = 'europe_paris';
          }
          const currentTimeValue = cfg.time_current || manualValue || '';
          timeCurrentLabel.textContent = currentTimeValue ? currentTimeValue.replace('T', ' ') : '‚Äî';
          updateTimeControls(currentTimeValue || manualValue);
          if (cfg.filtration_mode) filtrationMode.value = cfg.filtration_mode;
          if (cfg.filtration_start) filtrationStart.value = cfg.filtration_start;
          if (cfg.filtration_end) filtrationEnd.value = cfg.filtration_end;
          if (filtrationMode.value === 'manual') {
            cachedManualStart = filtrationStart.value;
            cachedManualEnd = filtrationEnd.value;
          }
          updateFiltrationControls();
          wifiSsidEl.textContent = cfg.wifi_ssid || '‚Äî';
          wifiIpEl.textContent = cfg.wifi_ip || '‚Äî';
          wifiModeEl.textContent = cfg.wifi_mode || '‚Äî';
          wifiMdnsEl.textContent = cfg.mdns_host || 'poolcontroller.local';
        });
      }

      // Charger la configuration au d√©marrage
      loadConfig();

      // Event listeners
      toggle.addEventListener('change', () => {
        // Mettre √† jour la pastille imm√©diatement (grise si d√©sactiv√©, rouge si activ√© mais pas encore connect√©)
        updateMqttStatusIndicator(toggle.checked, false);
        sendConfig(collectConfig());
        // Recharger la config apr√®s 6 secondes pour laisser le temps √† MQTT de se connecter
        // (d√©lai anti-spam de 5s + 1s de marge)
        setTimeout(() => loadConfig(), 6000);
      });

      phToggle.addEventListener('change', () => {
        updatePhControls();
        sendConfig(collectConfig());
      });

      orpToggle.addEventListener('change', () => {
        updateOrpControls();
        sendConfig(collectConfig());
      });

      // Auto-save pour les champs de valeurs
      phInput.addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      orpInput.addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      phLimitInput.addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      orpLimitInput.addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      document.getElementById('mqtt_server').addEventListener('change', () => {
        sendConfig(collectConfig());
        // Recharger apr√®s 6s pour mettre √† jour le statut MQTT
        setTimeout(() => loadConfig(), 6000);
      });

      document.getElementById('mqtt_port').addEventListener('change', () => {
        sendConfig(collectConfig());
        // Recharger apr√®s 6s pour mettre √† jour le statut MQTT
        setTimeout(() => loadConfig(), 6000);
      });

      document.getElementById('mqtt_topic').addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      document.getElementById('mqtt_username').addEventListener('change', () => {
        sendConfig(collectConfig());
        // Recharger apr√®s 6s pour mettre √† jour le statut MQTT
        setTimeout(() => loadConfig(), 6000);
      });

      document.getElementById('mqtt_password').addEventListener('change', () => {
        sendConfig(collectConfig());
        // Recharger apr√®s 6s pour mettre √† jour le statut MQTT
        setTimeout(() => loadConfig(), 6000);
      });

      phPumpSelect.addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      orpPumpSelect.addEventListener('change', () => {
        sendConfig(collectConfig());
      });

      phSensorPin.addEventListener('change', () => {
        updatePhControls();
        sendConfig(collectConfig());
      });

      orpSensorPin.addEventListener('change', () => {
        updateOrpControls();
        sendConfig(collectConfig());
      });

      // Calibration pH - Point neutre (pH 7.0) - DFRobot SEN0161-V2
      phCalNeutralBtn.addEventListener('click', () => {
        if (!confirm('Assurez-vous que la sonde est plong√©e dans la solution tampon pH 7.0 et que la lecture est stable.\n\nContinuer la calibration ?')) {
          return;
        }

        phCalNeutralBtn.disabled = true;
        phCalNeutralStatus.textContent = '‚è≥ Calibration en cours...';
        phCalNeutralStatus.style.color = '#ffc107';

        // Appeler l'API de calibration (√† impl√©menter c√¥t√© serveur)
        fetch('/calibrate_ph_neutral', { method: 'POST' })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              phCalNeutralStatus.textContent = '‚úì Calibr√© avec succ√®s';
              phCalNeutralStatus.style.color = '#28a745';

              // Mettre √† jour la date de calibration
              const config = collectConfig();
              config.ph_calibration_date = new Date().toISOString();
              config.ph_calibration_temp = data.temperature || null;
              sendConfig(config);

              alert('Calibration pH 7.0 r√©ussie!\n\nVous pouvez maintenant calibrer le point pH 4.0 pour une calibration 2 points.');
              setTimeout(() => loadConfig(), 500);
            } else {
              throw new Error(data.error || 'Calibration √©chou√©e');
            }
          })
          .catch(err => {
            phCalNeutralStatus.textContent = '‚ùå Erreur';
            phCalNeutralStatus.style.color = '#dc3545';
            alert('Erreur lors de la calibration pH 7.0:\n' + err.message);
          })
          .finally(() => {
            phCalNeutralBtn.disabled = false;
          });
      });

      // Calibration pH - Point acide (pH 4.0) - DFRobot SEN0161-V2
      phCalAcidBtn.addEventListener('click', () => {
        if (!confirm('Assurez-vous que la sonde est plong√©e dans la solution tampon pH 4.0 et que la lecture est stable.\n\nATTENTION: Calibrez d\'abord le pH 7.0 si ce n\'est pas d√©j√† fait!\n\nContinuer la calibration ?')) {
          return;
        }

        phCalAcidBtn.disabled = true;
        phCalAcidStatus.textContent = '‚è≥ Calibration en cours...';
        phCalAcidStatus.style.color = '#ffc107';

        // Appeler l'API de calibration (√† impl√©menter c√¥t√© serveur)
        fetch('/calibrate_ph_acid', { method: 'POST' })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              phCalAcidStatus.textContent = '‚úì Calibr√© avec succ√®s';
              phCalAcidStatus.style.color = '#28a745';

              // Mettre √† jour la date de calibration
              const config = collectConfig();
              config.ph_calibration_date = new Date().toISOString();
              config.ph_calibration_temp = data.temperature || null;
              sendConfig(config);

              alert('Calibration pH 4.0 r√©ussie!\n\nVotre sonde pH est maintenant calibr√©e avec 2 points (pH 4.0 et 7.0).');
              setTimeout(() => loadConfig(), 500);
            } else {
              throw new Error(data.error || 'Calibration √©chou√©e');
            }
          })
          .catch(err => {
            phCalAcidStatus.textContent = '‚ùå Erreur';
            phCalAcidStatus.style.color = '#dc3545';
            alert('Erreur lors de la calibration pH 4.0:\n' + err.message);
          })
          .finally(() => {
            phCalAcidBtn.disabled = false;
          });
      });

      // R√©initialiser calibration pH - DFRobot SEN0161-V2
      phCalResetBtn.addEventListener('click', () => {
        if (!confirm('‚ö†Ô∏è ATTENTION: Cela effacera toute la calibration pH!\n\nVoulez-vous vraiment r√©initialiser la calibration pH ?')) {
          return;
        }

        phCalResetBtn.disabled = true;

        // Appeler l'API de r√©initialisation (√† impl√©menter c√¥t√© serveur)
        fetch('/clear_ph_calibration', { method: 'POST' })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              const config = collectConfig();
              config.ph_calibration_date = '';
              config.ph_calibration_temp = null;
              sendConfig(config);

              alert('Calibration pH r√©initialis√©e!\n\nVous devrez recalibrer la sonde (pH 7.0 puis pH 4.0).');
              setTimeout(() => loadConfig(), 500);
            } else {
              throw new Error(data.error || 'R√©initialisation √©chou√©e');
            }
          })
          .catch(err => {
            alert('Erreur lors de la r√©initialisation:\n' + err.message);
          })
          .finally(() => {
            phCalResetBtn.disabled = false;
          });
      });

      orpCalibrateBtn.addEventListener('click', () => {
        const referenceValue = parseFloat(orpReferenceValue.value);

        if (isNaN(referenceValue) || referenceValue < 0 || referenceValue > 1000) {
          alert('Veuillez entrer une valeur de r√©f√©rence ORP valide (0-1000 mV)');
          return;
        }

        if (!latestSensorData) {
          alert('Aucune donn√©e capteur disponible.\nVeuillez patienter quelques secondes et r√©essayer.');
          return;
        }

        const data = latestSensorData;

        if (!data || typeof data !== 'object') {
          alert('Donn√©es invalides');
          return;
        }

        // Utiliser la valeur brute (sans offset) pour le calcul
        const currentOrpRaw = data.orp_raw;
        const currentOrpCalibrated = data.orp;

        if (isNaN(currentOrpRaw) || currentOrpRaw === null || currentOrpRaw === undefined) {
          alert('Impossible de lire la valeur ORP actuelle\nValeur re√ßue: ' + currentOrpRaw);
          return;
        }

        // Calculate offset: reference - raw value (NOT calibrated value!)
        const offset = referenceValue - currentOrpRaw;

        // Get current time
        const now = new Date();
        const calibrationDate = now.toISOString();

        // Build confirmation message
        let confirmMsg = `Calibration ORP\n\n`;
        confirmMsg += `Valeur brute mesur√©e: ${currentOrpRaw.toFixed(1)} mV\n`;
        confirmMsg += `Valeur de r√©f√©rence: ${referenceValue.toFixed(0)} mV\n`;
        confirmMsg += `Offset calcul√©: ${offset.toFixed(1)} mV\n`;
        confirmMsg += `\nVoulez-vous appliquer cette calibration ?`;

        if (!confirm(confirmMsg)) {
          return;
        }

        // Save configuration with all calibration data
        const config = collectConfig();
        config.orp_calibration_offset = offset;
        config.orp_calibration_date = calibrationDate;
        config.orp_calibration_reference = referenceValue;

        sendConfig(config);

        // Mettre √† jour l'affichage de toutes les informations de calibration
        const orpOffsetEl = document.getElementById('orp_current_offset');
        if (orpOffsetEl) {
          orpOffsetEl.textContent = `${offset >= 0 ? '+' : ''}${offset.toFixed(1)} mV`;
          orpOffsetEl.style.color = '#007bff';
        }

        const orpRefEl = document.getElementById('orp_calibration_reference');
        if (orpRefEl) {
          orpRefEl.textContent = `${referenceValue.toFixed(0)} mV`;
        }

        const orpDateEl = document.getElementById('orp_calibration_date');
        if (orpDateEl) {
          const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
          orpDateEl.textContent = now.toLocaleDateString('fr-FR', options);
        }

        alert(`Calibration ORP effectu√©e\nOffset appliqu√© : ${offset.toFixed(1)} mV`);
        orpReferenceValue.value = '';
      });

      // Event listener pour changement de type de calibration ORP
      orpCalType.addEventListener('change', () => {
        const type = orpCalType.value;
        if (type === '1point') {
          orpCal1Point.style.display = 'block';
          orpCal2Points.style.display = 'none';
          // R√©initialiser les variables de calibration 2 points
          orpPoint1Measured = null;
          orpPoint1Reference = null;
          orpPoint1Status.textContent = '';
          orpCalibrate2PointsBtn.disabled = true;
        } else if (type === '2points') {
          orpCal1Point.style.display = 'none';
          orpCal2Points.style.display = 'block';
        }
      });

      // Event listener pour sauvegarder le point 1 (calibration 2 points)
      orpSavePoint1Btn.addEventListener('click', () => {
        const ref1 = parseFloat(orpRef1.value);

        if (isNaN(ref1) || ref1 < 0 || ref1 > 1000) {
          alert('Veuillez entrer une valeur de r√©f√©rence valide (0-1000 mV) pour le point 1');
          return;
        }

        if (!latestSensorData) {
          alert('Aucune donn√©e capteur disponible.\nVeuillez patienter quelques secondes et r√©essayer.');
          return;
        }

        const measured1 = latestSensorData.orp_raw;

        if (isNaN(measured1) || measured1 === null || measured1 === undefined) {
          alert('Impossible de lire la valeur ORP actuelle\nValeur re√ßue: ' + measured1);
          return;
        }

        // Sauvegarder le point 1
        orpPoint1Measured = measured1;
        orpPoint1Reference = ref1;

        // Afficher le statut
        orpPoint1Status.textContent = `‚úì Point 1: ${measured1.toFixed(1)} mV ‚Üí ${ref1.toFixed(0)} mV`;
        orpPoint1Status.style.color = '#28a745';
        orpPoint1Status.style.fontWeight = '500';

        // Activer le bouton de calibration
        orpCalibrate2PointsBtn.disabled = false;

        alert(`Point 1 m√©moris√©\n\nMesure brute: ${measured1.toFixed(1)} mV\nR√©f√©rence: ${ref1.toFixed(0)} mV\n\nVous pouvez maintenant plonger la sonde dans la solution de r√©f√©rence 2 et calibrer.`);
      });

      // Event listener pour calibration 2 points ORP
      orpCalibrate2PointsBtn.addEventListener('click', () => {
        const ref2 = parseFloat(orpRef2.value);

        if (isNaN(ref2) || ref2 < 0 || ref2 > 1000) {
          alert('Veuillez entrer une valeur de r√©f√©rence valide (0-1000 mV) pour le point 2');
          return;
        }

        if (!latestSensorData) {
          alert('Aucune donn√©e capteur disponible.\nVeuillez patienter quelques secondes et r√©essayer.');
          return;
        }

        const measured2 = latestSensorData.orp_raw;

        if (isNaN(measured2) || measured2 === null || measured2 === undefined) {
          alert('Impossible de lire la valeur ORP actuelle\nValeur re√ßue: ' + measured2);
          return;
        }

        // V√©rifier que les deux points sont diff√©rents
        if (Math.abs(orpPoint1Measured - measured2) < 10) {
          alert('‚ö†Ô∏è Les deux points de mesure sont trop proches!\n\n√âcart mesur√©: ' + Math.abs(orpPoint1Measured - measured2).toFixed(1) + ' mV\n\nUtilisez deux solutions de r√©f√©rence avec au moins 100 mV d\'√©cart.');
          return;
        }

        if (Math.abs(orpPoint1Reference - ref2) < 50) {
          alert('‚ö†Ô∏è Les deux valeurs de r√©f√©rence sont trop proches!\n\n√âcart: ' + Math.abs(orpPoint1Reference - ref2).toFixed(0) + ' mV\n\nUtilisez deux solutions de r√©f√©rence avec au moins 100 mV d\'√©cart.');
          return;
        }

        // Calculer slope et offset
        // Formule: ORP_final = (ORP_brut * slope) + offset
        // Point 1: ref1 = measured1 * slope + offset
        // Point 2: ref2 = measured2 * slope + offset
        // => slope = (ref2 - ref1) / (measured2 - measured1)
        // => offset = ref1 - (measured1 * slope)
        const slope = (ref2 - orpPoint1Reference) / (measured2 - orpPoint1Measured);
        const offset = orpPoint1Reference - (orpPoint1Measured * slope);

        // Get current time
        const now = new Date();
        const calibrationDate = now.toISOString();

        // Build confirmation message
        let confirmMsg = `Calibration ORP 2 points\n\n`;
        confirmMsg += `Point 1:\n`;
        confirmMsg += `  Mesure brute: ${orpPoint1Measured.toFixed(1)} mV\n`;
        confirmMsg += `  R√©f√©rence: ${orpPoint1Reference.toFixed(0)} mV\n\n`;
        confirmMsg += `Point 2:\n`;
        confirmMsg += `  Mesure brute: ${measured2.toFixed(1)} mV\n`;
        confirmMsg += `  R√©f√©rence: ${ref2.toFixed(0)} mV\n\n`;
        confirmMsg += `Slope calcul√©: ${slope.toFixed(3)}\n`;
        confirmMsg += `Offset calcul√©: ${offset.toFixed(1)} mV\n`;
        confirmMsg += `\nVoulez-vous appliquer cette calibration ?`;

        if (!confirm(confirmMsg)) {
          return;
        }

        // Save configuration with all calibration data
        const config = collectConfig();
        config.orp_calibration_slope = slope;
        config.orp_calibration_offset = offset;
        config.orp_calibration_date = calibrationDate;
        config.orp_calibration_reference = ref2; // Stocker la derni√®re r√©f√©rence utilis√©e

        sendConfig(config);

        // Mettre √† jour l'affichage
        const orpOffsetEl = document.getElementById('orp_current_offset');
        if (orpOffsetEl) {
          orpOffsetEl.textContent = `${offset >= 0 ? '+' : ''}${offset.toFixed(1)} mV`;
          orpOffsetEl.style.color = '#007bff';
        }

        const orpSlopeEl = document.getElementById('orp_current_slope');
        if (orpSlopeEl) {
          orpSlopeEl.textContent = slope.toFixed(3);
          orpSlopeEl.style.color = '#007bff';
        }

        const orpRefEl = document.getElementById('orp_calibration_reference');
        if (orpRefEl) {
          orpRefEl.textContent = `${ref2.toFixed(0)} mV`;
        }

        const orpDateEl = document.getElementById('orp_calibration_date');
        if (orpDateEl) {
          const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
          orpDateEl.textContent = now.toLocaleDateString('fr-FR', options);
        }

        alert(`Calibration ORP 2 points effectu√©e\n\nSlope: ${slope.toFixed(3)}\nOffset: ${offset.toFixed(1)} mV`);

        // R√©initialiser
        orpRef1.value = '';
        orpRef2.value = '';
        orpPoint1Measured = null;
        orpPoint1Reference = null;
        orpPoint1Status.textContent = '';
        orpCalibrate2PointsBtn.disabled = true;
      });

      filtrationMode.addEventListener('change', () => {
        updateFiltrationControls(true);
        sendConfig(collectConfig());
      });

      filtrationStart.addEventListener('change', () => {
        cachedManualStart = filtrationStart.value;
        if (filtrationMode.value === 'manual') {
          sendConfig(collectConfig());
        }
      });

      filtrationEnd.addEventListener('change', () => {
        cachedManualEnd = filtrationEnd.value;
        if (filtrationMode.value === 'manual') {
          sendConfig(collectConfig());
        }
      });

      timeUseNtp.addEventListener('change', () => {
        updateTimeControls(timeManualInput.value);
        sendConfig(collectConfig());
      });

      timeNtpServer.addEventListener('change', () => {
        if (timeUseNtp.checked) {
          sendConfig(collectConfig());
        }
      });

      timeTimezone.addEventListener('change', () => {
        cachedManualTime = timeManualInput.value;
        updateTimeControls(timeManualInput.value);
        sendConfig(collectConfig());
      });

      timeManualInput.addEventListener('input', () => {
        cachedManualTime = timeManualInput.value;
        if (!timeUseNtp.checked) {
          timeCurrentLabel.textContent = cachedManualTime ? cachedManualTime.replace('T', ' ') : '‚Äî';
        }
      });

      restartApBtn.addEventListener('click', () => {
        if (!confirm('Red√©marrer en mode point d\'acc√®s ?')) return;
        fetch('/reboot-ap', { method: 'POST' })
          .then(() => alert('Red√©marrage en mode AP en cours...'))
          .catch(() => alert('Impossible de red√©marrer. V√©rifiez la connexion.'));
      });

      updateTimeControls();
      updateFiltrationControls();

      // ========== Onglet Syst√®me ==========

      const updateFileInput = document.getElementById('update_file');
      const updateBtn = document.getElementById('update_btn');
      const updateProgress = document.getElementById('update_progress');
      const updateProgressBar = document.getElementById('update_progress_bar');
      const updateStatus = document.getElementById('update_status');
      const refreshInfoBtn = document.getElementById('refresh_info_btn');
      const updateType = document.getElementById('update_type');

      // Charger les informations syst√®me
      function loadSystemInfo() {
        fetch('/get-system-info')
          .then(res => res.json())
          .then(data => {
            document.getElementById('sys_firmware_version').textContent = data.firmware_version || '‚Äî';
            document.getElementById('sys_build_date').textContent = (data.build_date + ' ' + data.build_time) || '‚Äî';

            // Uptime
            const days = data.uptime_days || 0;
            const hours = data.uptime_hours || 0;
            const minutes = data.uptime_minutes || 0;
            document.getElementById('sys_uptime').textContent = `${days}j ${hours}h ${minutes}min`;

            // Informations mat√©riel
            document.getElementById('sys_chip_model').textContent = data.chip_model + ' rev' + data.chip_revision + ' (' + data.chip_cores + ' cores)';
            document.getElementById('sys_cpu_freq').textContent = data.cpu_freq_mhz + ' MHz';

            // M√©moire
            const freeHeapKb = Math.round(data.free_heap / 1024);
            const heapSizeKb = Math.round(data.heap_size / 1024);
            const heapPercent = Math.round((data.free_heap / data.heap_size) * 100);
            document.getElementById('sys_free_heap').textContent = `${freeHeapKb} KB / ${heapSizeKb} KB (${heapPercent}% libre)`;

            // Flash
            const flashSizeMb = Math.round(data.flash_size / (1024 * 1024));
            document.getElementById('sys_flash_size').textContent = flashSizeMb + ' MB @ ' + Math.round(data.flash_speed / 1000000) + ' MHz';

            // Syst√®me de fichiers
            const fsUsedKb = Math.round(data.fs_used_bytes / 1024);
            const fsTotalKb = Math.round(data.fs_total_bytes / 1024);
            const fsPercent = Math.round((data.fs_used_bytes / data.fs_total_bytes) * 100);
            document.getElementById('sys_fs_usage').textContent = `${fsUsedKb} KB / ${fsTotalKb} KB (${fsPercent}% utilis√©)`;

            // WiFi
            document.getElementById('sys_wifi_rssi').textContent = data.wifi_rssi + ' dBm';
            document.getElementById('sys_mac_address').textContent = data.wifi_mac || '‚Äî';
          })
          .catch(err => {
            console.error('Erreur chargement infos syst√®me:', err);
          });
      }

      // Activer/d√©sactiver le bouton de mise √† jour
      updateFileInput.addEventListener('change', () => {
        updateBtn.disabled = !updateFileInput.files || updateFileInput.files.length === 0;
      });

      // G√©rer la mise √† jour OTA
      updateBtn.addEventListener('click', async () => {
        const file = updateFileInput.files[0];
        if (!file) {
          alert('Veuillez s√©lectionner un fichier.');
          return;
        }

        // V√©rifier l'extension selon le type
        const type = updateType.value;
        if (type === 'filesystem' && !file.name.endsWith('.littlefs.bin') && !file.name.endsWith('.fs.bin')) {
          if (!confirm('Le fichier ne semble pas √™tre un fichier filesystem (.littlefs.bin). Continuer quand m√™me ?')) {
            return;
          }
        } else if (type === 'firmware' && !file.name.endsWith('.bin')) {
          if (!confirm('Le fichier ne semble pas √™tre un firmware (.bin). Continuer quand m√™me ?')) {
            return;
          }
        }

        if (!confirm(`‚ö†Ô∏è ATTENTION\n\nVous allez mettre √† jour le ${type === 'firmware' ? 'firmware' : 'syst√®me de fichiers'}.\n\n‚Ä¢ Ne coupez PAS l'alimentation pendant la mise √† jour\n‚Ä¢ L'ESP32 red√©marrera automatiquement apr√®s la mise √† jour\n‚Ä¢ Cette op√©ration peut prendre quelques minutes\n\nContinuer ?`)) {
          return;
        }

        // D√©sactiver les boutons
        updateBtn.disabled = true;
        updateFileInput.disabled = true;
        updateType.disabled = true;
        refreshInfoBtn.disabled = true;

        // Afficher la progression
        updateProgress.style.display = 'block';
        updateProgressBar.style.width = '0%';
        updateProgressBar.textContent = '0%';
        updateStatus.textContent = 'Envoi du fichier...';

        try {
          const formData = new FormData();
          formData.append('update', file);

          const xhr = new XMLHttpRequest();

          xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable) {
              const percent = Math.round((e.loaded / e.total) * 100);
              updateProgressBar.style.width = percent + '%';
              updateProgressBar.textContent = percent + '%';
              updateStatus.textContent = `Envoi: ${percent}%`;
            }
          });

          xhr.addEventListener('load', () => {
            if (xhr.status === 200) {
              updateProgressBar.style.width = '100%';
              updateProgressBar.textContent = '100%';
              updateProgressBar.style.backgroundColor = '#34c759';
              updateStatus.textContent = '‚úì Mise √† jour r√©ussie! Red√©marrage en cours...';

              setTimeout(() => {
                alert('Mise √† jour r√©ussie!\n\nL\'ESP32 red√©marre. La page se rechargera automatiquement dans 30 secondes.');
                setTimeout(() => {
                  window.location.reload();
                }, 30000);
              }, 1000);
            } else {
              throw new Error('Erreur HTTP: ' + xhr.status);
            }
          });

          xhr.addEventListener('error', () => {
            throw new Error('Erreur r√©seau lors de l\'envoi');
          });

          xhr.open('POST', '/update');
          xhr.send(formData);

        } catch (error) {
          updateProgressBar.style.backgroundColor = '#ff3b30';
          updateStatus.textContent = '‚ùå Erreur: ' + error.message;
          alert('Erreur lors de la mise √† jour:\n' + error.message);

          // R√©activer les boutons
          updateBtn.disabled = false;
          updateFileInput.disabled = false;
          updateType.disabled = false;
          refreshInfoBtn.disabled = false;
        }
      });

      // Bouton actualiser
      refreshInfoBtn.addEventListener('click', () => {
        loadSystemInfo();
      });

      // Charger les infos syst√®me au chargement de la page
      loadSystemInfo();

      // ========== Gestion des logs ==========
      let autoScrollLogs = true; // Activer le scroll automatique par d√©faut

      function matchesFilter(message, filter) {
        if (filter === 'all') return true;
        const msg = message.toLowerCase();

        if (filter === 'temp') {
          return msg.includes('temp:') || msg.includes('temp√©rature') || msg.includes('ds18b20');
        }
        if (filter === 'ph') {
          return msg.includes('ph:') || msg.includes('ph ') || msg.startsWith('ph');
        }
        if (filter === 'orp') {
          return msg.includes('orp:') || msg.includes('orp ');
        }
        return false;
      }

      function loadLogs(showLoading = false) {
        const logsContent = document.getElementById('logs_content');
        const logsContainer = document.getElementById('logs_container');
        const filter = document.getElementById('logs_filter').value;

        // Seulement afficher "Chargement" si demand√© (premier chargement ou refresh manuel)
        if (showLoading) {
          logsContent.innerHTML = 'Chargement des logs...';
        }

        fetch('/get-logs')
          .then(res => res.json())
          .then(data => {
            if (data.logs && data.logs.length > 0) {
              let html = '';
              let count = 0;

              data.logs.forEach(log => {
                // Appliquer le filtre
                if (!matchesFilter(log.message || '', filter)) {
                  return; // Skip ce log
                }

                count++;
                const levelColors = {
                  'DEBUG': '#6c757d',
                  'INFO': '#0dcaf0',
                  'WARNING': '#ffc107',
                  'ERROR': '#dc3545',
                  'CRITICAL': '#ff0000'
                };
                const color = levelColors[log.level] || '#d4d4d4';
                html += `<div style="margin-bottom: 8px;">`;
                html += `<span style="color: #6c757d;">[${log.timestamp || log.time || ''}]</span> `;
                html += `<span style="color: ${color}; font-weight: 600;">${log.level || ''}</span> `;
                html += `<span>${log.message || ''}</span>`;
                html += `</div>`;
              });

              if (count === 0) {
                logsContent.innerHTML = '<div style="color: #6c757d; text-align: center;">Aucun log correspondant au filtre</div>';
              } else {
                // M√©moriser la position de scroll avant mise √† jour
                const wasAtBottom = logsContainer.scrollHeight - logsContainer.scrollTop <= logsContainer.clientHeight + 50;

                logsContent.innerHTML = html;

                // Scroller automatiquement vers le bas seulement si on √©tait d√©j√† en bas ou si autoScroll est activ√©
                if (autoScrollLogs || wasAtBottom) {
                  logsContainer.scrollTop = logsContainer.scrollHeight;
                }
              }
            } else {
              logsContent.innerHTML = '<div style="color: #6c757d; text-align: center;">Aucun log disponible</div>';
            }
          })
          .catch(err => {
            console.error('Erreur chargement logs:', err);
            logsContent.innerHTML = '<div style="color: #dc3545;">Erreur lors du chargement des logs</div>';
          });
      }

      // D√©tecter si l'utilisateur scroll manuellement pour d√©sactiver l'auto-scroll
      document.getElementById('logs_container').addEventListener('scroll', function() {
        const logsContainer = this;
        const isAtBottom = logsContainer.scrollHeight - logsContainer.scrollTop <= logsContainer.clientHeight + 50;
        autoScrollLogs = isAtBottom;
      });

      // Bouton actualiser les logs
      document.getElementById('refresh_logs_btn').addEventListener('click', function() {
        loadLogs(true); // Afficher "Chargement" lors du refresh manuel
      });

      // Bouton effacer l'affichage des logs
      document.getElementById('clear_logs_display_btn').addEventListener('click', function() {
        document.getElementById('logs_content').innerHTML = '<div style="color: #6c757d; text-align: center;">Affichage effac√© - Cliquez sur "Actualiser les logs" pour recharger</div>';
      });

      // Changement du filtre de logs
      document.getElementById('logs_filter').addEventListener('change', function() {
        loadLogs(false); // Recharger les logs avec le nouveau filtre
      });

      // Gestion des sliders de puissance pompes
      const pump1DutySlider = document.getElementById('pump1_duty');
      const pump2DutySlider = document.getElementById('pump2_duty');
      const pump1DutyValue = document.getElementById('pump1_duty_value');
      const pump2DutyValue = document.getElementById('pump2_duty_value');
      const pump1DutyPwm = document.getElementById('pump1_duty_pwm');
      const pump2DutyPwm = document.getElementById('pump2_duty_pwm');

      // Mettre √† jour l'affichage du slider pompe 1
      pump1DutySlider.addEventListener('input', function() {
        const duty = parseInt(this.value);
        const percent = Math.round((duty / 255) * 100);
        pump1DutyValue.textContent = percent;
        pump1DutyPwm.textContent = duty;
      });

      // Mettre √† jour l'affichage du slider pompe 2
      pump2DutySlider.addEventListener('input', function() {
        const duty = parseInt(this.value);
        const percent = Math.round((duty / 255) * 100);
        pump2DutyValue.textContent = percent;
        pump2DutyPwm.textContent = duty;
      });

      // Appliquer la puissance lorsque le slider est rel√¢ch√©
      pump1DutySlider.addEventListener('change', function() {
        const switch1 = document.getElementById('pump1_test');
        if (switch1.checked) {
          const duty = parseInt(this.value);
          fetch('/pump1/duty/' + duty, { method: 'POST' })
            .then(response => response.text())
            .then(data => {
              if (data === 'OK') {
                console.log('Pompe 1 duty=' + duty);
              }
            })
            .catch(err => console.error('Erreur:', err));
        }
      });

      pump2DutySlider.addEventListener('change', function() {
        const switch2 = document.getElementById('pump2_test');
        if (switch2.checked) {
          const duty = parseInt(this.value);
          fetch('/pump2/duty/' + duty, { method: 'POST' })
            .then(response => response.text())
            .then(data => {
              if (data === 'OK') {
                console.log('Pompe 2 duty=' + duty);
              }
            })
            .catch(err => console.error('Erreur:', err));
        }
      });

      // Gestion des switches de test des pompes
      document.getElementById('pump1_test').addEventListener('change', function() {
        const slider = document.getElementById('pump1_duty');

        if (this.checked) {
          // Activer la pompe avec la puissance du slider
          const duty = parseInt(slider.value);

          fetch('/pump1/duty/' + duty, { method: 'POST' })
            .then(response => response.text())
            .then(data => {
              if (data === 'OK') {
                console.log('Pompe 1 ON avec duty=' + duty);
              } else {
                alert('Erreur lors du contr√¥le de la pompe 1');
                this.checked = false;
              }
            })
            .catch(err => {
              console.error('Erreur:', err);
              alert('Erreur lors du contr√¥le de la pompe 1');
              this.checked = false;
            });
        } else {
          // D√©sactiver la pompe
          fetch('/pump1/off', { method: 'POST' })
            .then(response => response.text())
            .then(data => {
              if (data === 'OK') {
                console.log('Pompe 1 OFF');
              }
            })
            .catch(err => console.error('Erreur:', err));
        }
      });

      document.getElementById('pump2_test').addEventListener('change', function() {
        const slider = document.getElementById('pump2_duty');

        if (this.checked) {
          // Activer la pompe avec la puissance du slider
          const duty = parseInt(slider.value);

          fetch('/pump2/duty/' + duty, { method: 'POST' })
            .then(response => response.text())
            .then(data => {
              if (data === 'OK') {
                console.log('Pompe 2 ON avec duty=' + duty);
              } else {
                alert('Erreur lors du contr√¥le de la pompe 2');
                this.checked = false;
              }
            })
            .catch(err => {
              console.error('Erreur:', err);
              alert('Erreur lors du contr√¥le de la pompe 2');
              this.checked = false;
            });
        } else {
          // D√©sactiver la pompe
          fetch('/pump2/off', { method: 'POST' })
            .then(response => response.text())
            .then(data => {
              if (data === 'OK') {
                console.log('Pompe 2 OFF');
              }
            })
            .catch(err => console.error('Erreur:', err));
        }
      });

      // Charger les logs au chargement de la page
      loadLogs(true);

      // Actualiser les logs automatiquement toutes les 10 secondes si l'onglet Syst√®me est actif
      setInterval(function() {
        const systemTab = document.querySelector('.tab-panel[data-tab="system"]');
        if (systemTab && systemTab.classList.contains('active')) {
          loadLogs(false); // Pas de message "Chargement" pour les refresh automatiques
        }
      }, 10000);
    </script>
  </body>
</html>
